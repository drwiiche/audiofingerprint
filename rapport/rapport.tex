
\documentclass[12pt]{article}

\usepackage[francais]{babel}
\usepackage[latin1]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{graphicx}

\usepackage{subfig}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{float}
\usepackage{hyperref}


\renewcommand{\FrenchLabelItem}{\textbullet}

\title{Rapport de projet \bsc{si}380: Empreinte acoustique}
\author{Maxime \bsc{Sirbu}, 
	\texttt{maxime.sirbu@telecom-paristech.fr}\\
	Vincent \bsc{Timofti}, \texttt{vincent.timofti@telecom-paristech.fr}\\
	Télécom Paristech,\\\\
	}
\date{\today}



\graphicspath{ {./images/} }
\DeclareMathOperator*{\argmin}{arg\,min}

\begin{document}


\maketitle


\section{Introduction}

L'empreinte acoustique -- ou \emph{audio fingerprint} -- désigne une représentation d'un signal
audio pouvant servir d'identifiant unique. Le critère d'identifiabilté est en général celui de
l'oreille humaine, \emph{ie} deux signaux considérés comme identiques à l'écoute doivent avoir une
empreinte acoustique similaire. Par conséquent le système de construction d'empreinte doit être
robuste aux petites déformations qui n'altèrent pas l'identifiabilité du signal. Déformation telles
que l'ajout de bruit, la réverbération, la distortion\dots

De plus, un système efficace sera aussi robuste aux décalage temporels, c'est à dire qu'il sera
capable d'identifier un extrait de signal, même si celui si n'est pas aligné temporelement avec le
signal utilisé pour l'apprentissage de l'empreinte.

Le sytème d'identification par empreinte doit aussi être rapide et capable d'identifier un extrait
parmi un très grand nombre de signaux. Ceci pose deux contraintes majeures pour notre système :
\begin{itemize}
	\item La base de donnée contenant les empreintes ne doit pas être de taille trop importante.
	\item Les empreintes doivent permettre de différencier deux signaux distincts avec sans
		nécessiter une trop grande complexité.
\end{itemize}

Nous présenterons deux système de création et d'identification d'empreintes. Ces deux méthodes
utilisent un même principe de fonctionnement basé sur une table de hachage et des clés. Seule la
méthode de calcul des clés diffèrent :  La méthode «classique» -- utilisée notamment par
l'application shazam -- basée sur le spectrogramme du signal, et une méthode basée sur une
décomposition parcimonieuse du signal avec l'algorithme \emph{matching pursuit}.

Nous avons choisi de programmer en langage Python, et nous utilisons SQLite pour stocker les empreintes acoustiques.

Le code est accessible à l'adresse suivante :
\url{https://github.com/vince91/audiofingerprint}

\section{Principe de base}

\subsection{Recherche du plus proche voisin}
On défini une collection $\chi = \{x_1,x_2,\dots,x_L\}$ de $L$ signaux audios et un requête $q$ (un
nouvel extrait appartenant ou non à la base). On cherche alors l'élément de $\chi$ le plus proche de
$q$, c'est à dire son \emph{plus proche voisin}. Le problème revient alors à déterminer une mesure
de \emph{proximité} $d(x,y)$ entre deux signaux $x$ et $y$ tel que l'expression suivante donne le
\emph{plus proche voisin} de $q$ : \[ \argmin_{x \in \chi} d(x,q) \]

Bien entendu, le calcul de la mesure de proximité doit être le moins complexe possible. Impossible
donc d'effecture $L$ comparaison entre $q$ et les éléments de la collection. D'autant plus qu'en
pratique $q$ ne sera qu'un extrait du signal audio correspondant.


\subsection{Indexation}

\subsubsection{Descripteurs locaux}
L'idée derrière les deux algorithmes que nous présentons ici est d'utiliser des descripteurs locaux
pour la création de l'empreinte acoustique d'un signal. Ces descripteurs séléctionnent une partie de
l'information temporel et fréquentielle censé être caractéristique du signal donné.

On utilise ainsi ces descripteurs pour les signaux de référence et la requête. La fusion des
résultats de recherche des descripteurs de la requête nous permet alors de retrouver le signal ayant
le plus de similitudes mais  aussi le décalage de la requête avec celui-ci

\subsubsection{Table de hachage}
Pour pouvoir effectuer une comparaison efficace des descripteurs, il faut utiliser un méthode
d'indexation rapide. L'un des modèles les plus performants est celui de la table de hachage

Un table de hachage se base sur un fonctionnement par paire clé-valeur et sur une fonction de
hachage. Soit une paire clé-valeur $(c,v)$ dans un espace $\cal{C} \times \mathbb{V}$, une fonction
de hachage $h \,: \,\cal{C} \rightarrow \mathbb{H}$ associe à chaque clé un indice de localisation
dans la table. La localisation de la paire $(c,v)$ est alors déterminée par la valeur de $h(c)$ : il
n'est pas nécessaire de parcourir toute la table.

Dans les deux cas nous utiliserons alors ce système de table de hachage pour nos descripteurs
locaux. Chaque paire clé-valeur de la table sera construite comme le montre la figure~\ref{fig:ex_cles} : on sélectionne deux valeurs
temps-fréquence $(f_1,t_1)\, (f_2,t_2)$ par une méthode propre à chaque système, la clé est alors le
triplet \[ c = (f_1,f_2,\delta_t = t_1 - t_2)\]
La valeur enregistrée est le duet $(t_1,k)$ où $k \in [0,\dots,L-1]$ est l'indice du signal de référence.

\begin{figure}[htbp]
	\center
	\includegraphics[width=.7\textwidth]{exemple_cles_not}
	\caption{Construction des clés}
	\label{fig:ex_cles}
\end{figure}

Lors de la construction de la table, il est normal qu'une clé apparaisse plusieurs fois dans
différents signaux, voir dans le même signal. On stocke cependant bien chaque valeur associée à une
même clé.


\subsection{Recherche}

Pour effecuter une recherche de similarité pour une requêt $q$, on va calculer des descripteurs
locaux de la même manière que pour l'apprentissage de la base. Chaque clé $c_j$ calculée fait alors
l'objet d'une recherche dans la base et renvoie donc les couples $(t_j^l,k_j^l)$ associés à cette clé,
si celle ci existe. Connaissant le temps d'apparition $t_j$ de la clé, on peut en déduire le
décalage temporel de cette clé avec chaque occurence : $\tau_j^l =t_j^l - t_j$. Pour éviter d'être
trop précis quant au décalage, on quantifiera souvent $\tau_j^l$ par une valeur assez importante.

On pourrait alors établir le décompte du nombre de clé en commun entre la requête et chaque signal,
mais on traiterait alors chaque descripteur local indépendamment les uns des autres. Il est donc
plus intéressant de prendre en compte le décalage temporel.

On construit alors les histogrammes $\mathbf{H}_k(\tau) \, : \, \mathbb{Z} \rightarrow \mathbb{N}$
qui contienent pour chaque indice $k \in [0,\dots,L-1]$ le nombre de clés ayant un décalage $\tau$
comme montré en figure~\ref{fig:ex_hist}.


\begin{figure}[htbp]
	\center
	\includegraphics[width=.7\textwidth]{hist}
	\caption{Exemples d'histogrammes}
	\label{fig:ex_hist}
\end{figure}

Le \emph{plus proche voisin} est donc donné par :
\[
	k_q,\tau_q = \argmin_{k \in [0,\dots,L], \tau \in \mathbb{Z}} \mathbf{H}_k(\tau)
\]
où $\tau_q$ est le décalage de l'extrait avec son \emph{plus proche voisin}.



\section{Méthode Shazam}

\subsection{Spectrogramme}

Le signal audio duquel nous devons extraire l'empreinte acoustique est tout d'abord découpé en trame de 5 secondes. Pour chacune de ces trames, nous calculons son spectrogramme (en utilisant des fenêtres de 1024 échantillons et un recouvrement de 75\%).

\begin{figure}[htbp]
    \center
    \includegraphics[width=13cm]{shazam1.png}
    \caption{Passage dans le domaine temps-fréquence}
\end{figure}

\subsection{Extraction de pics d'intensité}

Le spectrogramme est découpé selon un quadrillage 10x10. Dans chaque case du quadrillage nous extrayons le point d'intensité maximale, qui définira un pic. Nous avons donc 100 pics d'itensité par trame de 5 secondes. Un pic est défini par sa position (sa fréquence et l'instant à laquel il apparaît) :

\begin{equation}
	p_i = (f_i, t_i)
\end{equation}

\begin{figure}[htbp]
    \center
    \includegraphics[width=13cm]{shazam2.png}
    \caption{Extraction des pics d'intensité pour une trame}
\end{figure}

\subsection{Couplage des pics}

Nous créons des couples à partir des pics d'intensité. Un couple constitue une clé, chaque clé est défini par la fréquence du premier pic, la fréquence du deuxième pic, et la différence des instants des deux pics :

\begin{equation}
\begin{split} 
	p_1 = (f_1, t_1), p_2 = (f_2, t_2) \\
	c_k = (f_1, f_2, \delta_t=t_2-t_1)
\end{split} 
\end{equation}

Pour constituer un couple les pics précedents doivent satisfaire 2 conditions :
\begin{itemize}
	\item $ t_2 > t_1 $
	\item la distance euclidiènne entre les 2 pics doit être inférieur à un certain seuil d (le nombre de clé que l'on prendra pour une trame dépendra de ce seuil)
\end{itemize}

Nous obtenons finalement une liste de clés pour chaque trame.

\begin{figure}[htbp]
    \center
    \includegraphics[width=13cm]{shazam3.png}
    \caption{Couplage des pics d'intensité}
\end{figure}

\subsection{Construction de la base de données}

Pour chaque musique de notre bibliothèque musicale (100 musiques), nous appliquons les méthodes précédentes et extrayons les clés, que nous enregistrons dans la base de données. Le processus est répété 5 fois, tout en faisant varier le seuil d (seuil de distance admissible entre les pics). Nous obtenons pour la méthode Shazam 5 base de données distinctes :

\begin{tabular}{|c|c|c|}
\hline
   BDD n° & Nombre de clés par seconde & Poids (Megaoctets) \\
\hline
   1 & 22,6 & 23 \\
\hline
   2 & 39,6 & 40,4 \\
\hline
   3 & 59 & 60 \\
\hline
   4 & 81,6 & 83,1 \\
\hline
   5 & 100,2 & 102,8  \\
\hline
\end{tabular}

La construction de la base de données pour 100 musique (et pour une durée totale de 8,1 heures de musique) prend entre 12 et 15 minutes.

%\emph{italique}
%\textbf{gras}
%\begin{itemize}
%	\item élément 1
%	\item élément 2
%\end{itemize}


\end{document}

